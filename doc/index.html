<!DOCTYPE html>
<html lang="en">
<head>
    <title>Vmodel.js</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css">
    <script src="//code.jquery.com/jquery-3.0.0.min.js"></script>
    <script src="../src/jquery.vmodel.min.js"></script>
    <script src="index.js"></script>
</head>
<body>
    <header>
        <div class="logo">
            Vmodel.js
        </div>
        <div class="logobar">
            <pre></pre>  
    </header>
    
    <ul class="dir">
        
    </ul>

    <div class="container">
        <h1>建議用法</h1>
        <pre>
            $.vmodel.create({
                selector: '.container', 
                model: '--message', 
                isautoload: true, 
                method: function (){
                    var vs = this;
                    this.autoload = ['init']; 

                    // 建立自訂方法，若需要自動被觸發，可將方法名稱寫入 autoload 的陣列
                    this.init = function (){
                        console.log('Hello World')
                    }
                }
            });
        </pre>
        <ul>
            <li>selector： 選擇器</li>
            <li>model： 為模組命名。前綴字元 -- 在被呼叫的時候可以被省略</li>
            <li>isautoload： 是否啟啟用自動讀取。</li>
            <li>method：{function}  主要方法</li>
            <li>vs：{object}  等同於內部使用 this ，這麼做是刻意與 this 命名區方，方便識別。</li>
            <li>autoload： {array | function} 自動觸發方法。可以是陣列，也可以是方法，但是方法務必回傳陣列。</li>
        </ul>
        <pre>
            this.autoload = ['init', 'click_button'];
            或
            this.autoload = function (){
                // 做一些處理
                return ['init', 'click_button'];
            }
        </pre>

        <h1>舊期寫法修正</h1>
        <pre>
            $(selector).vmodel(selector, model, isautoload, method);

            $(".container").vmodel(".container", "--message", true, function (){
                var vs = this;
                this.autoload = ['init'];
                this.yourfun = function (){
                    console.log('Hello World')
                }
            });
        </pre>
        <ul>
            <li>selector： 第一個須要與選擇器相同，如 .container ，這是 jQuery 3.0 以後的官方建議。</li>
            <li>model： 同 $.vmodel.create() 相關參數</li>
            <li>isautoload： 同 $.vmodel.create() 相關參數</li>
            <li>method： 同 $.vmodel.create() 相關參數</li>
        </ul>

        <h1>vs.root</h1>
        <p>
            取得跟位置的 $(selector)。
        </p>

        <h1>vs.selector</h1>
        <p>
            取得根指定的選擇器 selector
        </p>
        
        <h1>vs.struct(name, [status])</h1>
        <ul>
            <li>name： {string | array} 指地內部的方法名稱。可以使用字串或陣列。</li>
            <li>status： {bool} 預設 true，false 代表該方法未完成。</li>
        </ul>
        <p>
            告訴 vmodel 當前哪個方法的建構已經完成。配合 $.vmodel.get() 第三個參數指定使用視覺化屬性的時候，需要透過該方法來輔助。通常使用在 function 的結尾。例如這裡我們先定義好模組：
        </p>
        <pre>
            $.vmodel.create({
                selector: '.container',
                model: '--model',
                isautoload: false, // 不自動觸發
                method: function (){
                    var vs = this;
                    this.autoload = ['say']; //當呼叫時，須要自動讀取的方法為 say

                    this.say = function (){
                        
                        //....

                        vs.struct('say'); //指定當前的方法，代表已完成
                    }
                }
            });

            $.vmodel.get("model", true, function (){
                //...
            });
            
        </pre>


        <h1>$.vmodel.get([name], [autoload], [listen])</h1>
        <ul>
            <li>name： {string} 要讀取的模組名稱。若在定義時使用前綴字元『--』命名，在這裡記得不要寫；若為空，可返回整個倉儲。</li>
            <li>autoload： {bool} 是否觸發內部的 autoload。預設 false。</li>
            <li>listen： {bool | function(storage)} 監聽 autoload 中的每個方法，都被 vs.struct() 指定狀態為true 以後，所觸發的 callback。若指定為 true，仍然會啟用監聽完成後的視覺化屬性。</li>
        </ul>
        <p>
            可在任何時候，啟用 vmodel 自動讀取(初始化或是建構的概念)，或是呼叫 vmodel 模組內的某個方法。如果指定 listen ，那麼完成後會在根元素添加屬性 data-vmodel-history 作為紀錄。我們可以透過 $.vmodel.history() 取得。
        </p>
        <pre>
            $.vmodel.create({
                selector: '.container',
                model: '--model',
                isautoload: false, // 不觸發 autoload
                method: function (){
                    var vs = this;
                    this.autoload = ['init'];
                    this.init = function (){
                        //....
                    }
                }
            });

            $.vmodel.get("model", true);

            或

            $.vmodel.get("model", true, function (storage){
                //...
            });
        </pre>
        

        <h1>$.vmodel.history(name)</h1>
        <ul>
            <li>name： {string} 倉儲名稱</li>
        </ul>
        <p>
            取得視覺化的屬性物件。如果找不到，會返回 false。務必將取得的倉儲對象，設定 $.vmodel.get() 第三個參數。
        </p>

        <h1>$.vmodel.end([storage], [callback])</h1>
        <ul>
            <li>storage： {string | array} 指定要完成的倉儲名稱。若不指定，則當所有倉儲完成後，觸發 callback</li>
            <li>callback： function 等到倉儲完成後所觸發的回調函式。</li>
        </ul>
        <p>
            監控多組倉儲，直到完成視覺化後，即刻觸發函式。若要使用該方法，務必啟用 $.vmodel.get() 第三個參數為 true 或 function，以及配合 vs.struct()。
        </p>

        <h1>$.vmodel.delete([name])</h1>
        <ul>
            <li>name：{string} 要刪除的模組名稱。若不指定可全部刪除。</li>
        </ul>
        <p>刪除指定的倉儲。</p>

        <h1>$.vmodel.version()</h1>
        <p>取得當前的 vmodel 版本編號。</p>

    </div>

    

</body>
</html>